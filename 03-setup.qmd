---
---

# Reproducibility with Nix

<div style="text-align:center;">
```{r, echo = F}
# knitr::include_graphics("images/Nix_Snowflake_Logo.png")
```
</div>

In this chapter, we will explore the critical need for environment reproducibility in modern workflows. We will learn how to use `{rix}` to generate `default.nix` files and see how this enables building robust, cross-language environments for data science and software development.

## Why Reproducibility? Why Nix? *(1h30)*

### Motivation: Reproducibility in Scientific and Data Workflows

To ensure that a project is reproducible you need to deal with at least four
things:

- Make sure that the required/correct version of R (or any other language) is
  installed;
- Make sure that the required versions of packages are installed;
- Make sure that system dependencies are installed (for example, you’d need a
  working Java installation to install the `{rJava}` R package on Linux);
- Make sure that you can install all of this for the hardware you have on hand.

But in practice, one or most of these bullet points are missing from projects.
The goal of this course is to learn how to fullfill all the requirements to
build reproducible projects.

### Problems with Ad-Hoc Tools

Tools like Python's `venv` or R's `renv` only deal with some pieces of the
reproducibility puzzle. Often, they assume an underlying OS, do not capture
system-level dependencies (like `libxml2`, `pandoc`, or `curl`), and require
users to "rebuild" their environments from partial metadata. Docker helps but
introduces overhead, security challenges, and complexity, and just adding it to
your project doesn’t make it reproducible if you don’t explicitely take some
precautionary steps.

Traditional approaches fail to capture the entire dependency graph of a project
in a deterministic way. This leads to "it works on my machine" syndromes,
onboarding delays, and subtle bugs.

### Nix, a declarative package manager

Nix is a tool for reproducible builds and development environments, often
introduced as a package manager. It captures complete dependency trees, from
your programming language interpreter to every system-level library you rely on.
With Nix, environments are not recreated from documentation, but rebuilt
precisely from code.

Nix can be installed on Linux distributions, macOS and it even works on Windows
if you enable WSL2. In this course, we will use Nix mostly as a package manager
(but towards also as a build automation tool).

However Nix has quite a steep learning curve, so this is why for the purposes of
this course we are going to use an R package called `{rix}` to set up
reproducible environments.

### The rix package

`{rix}` is an R package (I’m the author) and its goal is to make writing Nix
expressions easy. With `{rix}` you can declare the environment you need using the
provided `rix()` function, which is the package's main function. Calling it
generates a file called `default.nix` which is then used by the Nix package
manager to build that environment. Ideally, you would set up such an environment
for each of your projects. You can then use this environment to either work
interactively, or run R or Python scripts. It is possible to have as many
environments as projects, and software that is common to environments will
simply be re-used and not get re-installed to save space. Environments are
isolated from each other, but can still interact with your system's files, unlike
with Docker where a volume must be mounted. While this is useful, it can
sometimes lead to issues. For example, if you already have R installed, and a
user library of R packages, more caution is required to properly use
environments managed by Nix.

You don’t need to have R installed or be an R user to use `{rix}`. If you have
Nix installed on your system, it is possible to "drop" into a temporary
environment with R and `{rix}` available and generate the required Nix
expression from there.

But first, let’s install Nix and try to use temporary shells.

### Installing Nix

#### For Windows users only: some prerequisites

If you are on Windows, you need the Windows Subsystem for Linux 2 (WSL2) to run
Nix. If you are on a recent version of Windows 10 or 11, you can simply run this
as an administrator in PowerShell:

```sh
wsl --install
```

You can find further installation notes at [this official MS
documentation](https://learn.microsoft.com/en-us/windows/wsl/install).

I recommend to activate `systemd` in Ubuntu WSL2, mainly because this supports
other users than `root` running Nix. To set this up, please do as outlined [this
official Ubuntu blog entry](https://ubuntu.com/blog/ubuntu-wsl-enable-systemd):

```sh
# in WSL2 Ubuntu shell

sudo -i
nano /etc/wsl.conf
```

This will open the `/etc/wsl.conf` in a nano, a command line text editor. Add
the following line:

```toml
[boot]
systemd=true
```

Save the file with CTRL-O and then quit nano with CTRL-X.
Then, type the following line in powershell:

```sh
wsl --shutdown
```

and then relaunch WSL (Ubuntu) from the start menu. For those of you running
Windows, we will be working exclusively from WSL2 now. If that is not an option,
then I highly recommend you set up a virtual machine with Ubuntu using
[VirtualBox](https://www.virtualbox.org/wiki/Downloads) for example, or
dual-boot Ubuntu.

Installing (and uninstalling) Nix is quite simple, thanks to the installer from
[Determinate
Systems](https://github.com/DeterminateSystems/nix-installer), a company
that provides services and tools built on Nix, and works the same way on Linux
(native or WSL2) and macOS.

#### Actually installing Nix

Do not use your operating system’s package manager to install Nix. Instead,
simply open a terminal and run the following line (on Windows, run this inside
WSL):

```{sh parsermd-chunk-1, eval = FALSE}
curl --proto '=https' --tlsv1.2 -sSf \
  -L https://install.determinate.systems/nix | \
  sh -s -- install
```

Then, install the `cachix` client and configure the `rstats-on-nix` cache: this
will install binary versions of many R packages which will speed up the building
process of environments:

```bash
nix-env -iA cachix -f https://cachix.org/api/v1/install
```

then use the cache:

```bash
cachix use rstats-on-nix
```

You only need to do this once per machine you want to use `{rix}` on. Many
thanks to [Cachix](https://www.cachix.org/) for sponsoring the `rstats-on-nix`
cache!

If you get this warning when trying to install software with Nix:

```
warning: ignoring the client-specified setting 'trusted-public-keys', because it is a restricted setting and you are not a trusted user
warning: ignoring untrusted substituter 'https://rstats-on-nix.cachix.org', you are not a trusted user.
Run `man nix.conf` for more information on the `substituters` configuration option.
warning: ignoring the client-specified setting 'trusted-public-keys', because it is a restricted setting and you are not a trusted user
```

Then this means that configuration was not successful. You need to add your user to `/etc/nix/nix.custom.conf`:

```
sudo vim /etc/nix/nix.custom.conf
```

then simply add this line in the file:

```
trusted-users = root YOURUSERNAME
```

where `YOURUSERNAME` is your current login user name.

### Temporary shells

You now have Nix installed; before continuing, it let’s see if everything works
(close all your terminals and reopen them) by droping into a temporary shell
with a tool you likely have not installed on your machine.

Open a terminal and run:

```bash
which sl
```

you will likely see something like this:

```bash
which: no sl in ....
```

now run this:

```bash
nix-shell -p sl
```

and then again:

```bash
which sl
```

this time you should see something like:

```bash
/nix/store/cndqpx74312xkrrgp842ifinkd4cg89g-sl-5.05/bin/sl
```

This is the path to the `sl` binary installed through Nix. The path starts with
`/nix/store`: the *Nix store* is where all the software installed through Nix is
stored. Now type `sl` and see what happens!

You can find the list of available packages
[here](https://search.nixos.org/packages?channel=unstable&from=0&size=50&sort=relevance&type=packages&query=).

## Session 1.2 – Dev Environments with Nix *(1h30)*

### Some Nix concepts

While temporary shells are useful for quick testing, this is not how Nix is
typically used in practice. Nix is a declarative package manager: users specify
what they want to build, and Nix takes care of the rest.

To do so, users write files called `default.nix` that contain the a so-called
Nix expression. This expression will contain the definition of a (or several)
*derivations*.

In `Nix` terminology, a derivation is *a specification for running an executable
on precisely defined input files to repeatably produce output files at uniquely
determined file system paths.*
([source](https://nix.dev/manual/nix/2.25/language/derivations))

In simpler terms, a derivation is a recipe with precisely defined inputs, steps,
and a fixed output. This means that given identical inputs and build steps, the
exact same output will always be produced. To achieve this level of
reproducibility, several important measures must be taken:

- All inputs to a derivation must be explicitly declared.
- Inputs include not just data files, but also software dependencies,
  configuration flags, and environment variables, essentially anything necessary
  for the build process.
- The build process takes place in a *hermetic* sandbox to ensure the exact same
  output is always produced.

The next sections of this document explain these three points in more detail.

### Derivations

Here is an example of a *simple* `Nix` expression:

```nix
let

 pkgs = import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/2025-04-11.tar.gz") {};

in

pkgs.stdenv.mkDerivation {
  name = "filtered_mtcars";
  buildInputs = [ pkgs.gawk ];
  dontUnpack = true;
  src = ./mtcars.csv;
  installPhase = ''
    mkdir -p $out
    awk -F',' 'NR==1 || $9=="1" { print }' $src > $out/filtered.csv
  '';
}
```

I won't go into details here, but what's important is that this code uses `awk`,
a common Unix data processing tool, to filter the `mtcars.csv` file to keep only
rows where the 9th column (the `am` column) equals 1. As you can see, a
significant amount of boilerplate code is required to perform this simple
operation. However, this approach is completely reproducible: the dependencies
are declared and pinned to a specific dated branch of our
`rstats-on-nix/nixpkgs` fork (more on this later), and the only thing that could
make this pipeline fail (though it's a bit of a stretch to call this a
*pipeline*) is if the `mtcars.csv` file is not provided to it. This expression
can be *instantiated* into a derivation, and the derivation is then built into
the actual output that interests us, namely the filtered `mtcars` data.

The derivation above uses the `Nix` builtin function `mkDerivation`: as its name
implies, this function *makes a derivation*. But there is also `mkShell`, which
is the function that builds a shell instead. Nix expressions that built a shell
is the kind of expressions `{rix}` generates for you.

###  Using `{rix}` to generate development environments

If you have successfully installed Nix, but don't have yet R installed on your
system, you could install R as you would usually do on your operating system,
and then install the `{rix}` package, and from there, generate project-specific
expressions and build them. But you could also install R using Nix. Actually, I
would even recommend you uninstall R and delete all your packages from your
computer and only manager R environments using Nix.

Running the following line in a terminal will drop you in an interactive R
session that you can use to start generating expressions:

```bash
nix-shell -p R rPackages.rix
```

This will drop you in a temporary shell with R and `{rix}` available. Navigate
to an empty directory to help a project, call it `rix-session-1`:

```bash
mkdir rix-session-1
```

and start R and load `{rix}`:

```bash
R
```

```r
library(rix)
```

you can now generate an expression by running the following code:

```r
rix(
  date = "2025-08-04",
  r_pkgs = c("dplyr", "ggplot2"), # add languageserver if you plan to use VS Code
  py_conf = list(
    py_version = "3.13",
    py_pkgs = c("polars", "great-tables")
  ),
  ide = "none",
  project_path = ".",
  overwrite = TRUE
)
```

This will write a file called `default.nix` in your project’s directory. This
`default.nix` contains a Nix expression which will build a shell that comes with
R, `{dplyr}` and `{ggplot2}` as they were on the the 4th of August 2025 on CRAN.
This will also add Python 3.13 and the `polars` and `great-tables` Python
packages as they were at the time in `nixpkgs` (more on this later). Finally,
the `ide` argument is set to `"none"`, because we don't want to use Nix to
manage an IDE. However, you should know that this is possible and useful in some
cases. See this
[vignette](https://docs.ropensci.org/rix/articles/e-configuring-ide.html) for
learning how to setup your IDE with Nix if you wish to do so. At the end of
this chapter we will learn how to set up Positron.

### Using `nix-shell` to Launch Environments

Once your file is in place, simply run:

```bash
nix-shell
```

This gives you an isolated shell session with all declared packages available.
You can test code, explore APIs, or install further tools within this session.

To remove the packages that were installed, call `nix-store --gc`. This will
call the garbage collector. If you want to avoid that an environment gets
garbage-collected, use `nix-build` instead of `nix-shell`. This will create a
symlink called `result` in your project’s root directory and `nix-store --gc`
won’t garbage-collect this environment until you manually remove `result`.

### Pinning with `nixpkgs`

To ensure long-term reproducibility, a pinned the version of Nixpkgs is used:

```nix
let
  pkgs = import (fetchTarball "https://github.com/rstats-on-nix/nixpkgs/archive/2025-08-04.tar.gz") {};
in
...
```

This is done automatically by `{rix}`. You could change the date manually if you
prefer, but I would recommend to always regenerate the `default.nix` using
`{rix}`.

### Installing Python packages not available via nixpkgs (impure)

Not all Python packages can be installed through Nix; unlike CRAN, Pypi doesn’t
get automatically mirrored and individual packages fixed by volunteers. Instead, specific Python
packages get packaged individually for Nix. Thus, it could very well be the case that a specific
Python package (or version of a Python package) that you need for a project is not 
available via nixpkgs.

In this case, it is still possible to use Python-specific package managers, like `uv`, 
to install packages. This is also useful if you work on a project with colleagues that 
use `uv` and that don’t want (yet) to use Nix. `uv`, is 10-100x faster than `pip` and
also generates a lock file for improved reproducibility.

The idea is to install `uv` in your shell (but not any Python nor Python packages):

```{r, eval = F}
rix(
  ...
  system_pkgs = c("uv"),
  ...
)
```

And then use `uv` from your shell as you would usually. We recommend specifying Python packages
in a `requirements.txt` file, and specifying explicit versions (e.g., `scanpy==1.11.4`).
Finally, we also recommend setting a shell hook to set up the virtual environment and install
the packages from the `requirements.txt` when entering the shell (mind the quotes):

```r
rix(
  ...
  system_pkgs = c("uv"),
  shell_hook = "
      if [ ! -f pyproject.toml ]; then
        uv init --python 3.13.5 # or whichever Python version you need
      fi
        uv add --requirements requirements.txt
      # Create alias so python uses uvs environment
      alias python='uv run python'
  ",
)
```

After running `nix-shell`, `uv` should initalize a Python project with the specified Python version
and install the packages listed in `requirements.txt` within the nix environment. 
This will take place each time `nix-shell` is called, however this will be cached and not installed each time.

To make sure everything works fine, you could simply start a Python interpreter and try to load
`numpy`. This should work fine, but if it doesn’t, the following error could be raised:

```bash
ImportError:

IMPORTANT: PLEASE READ THIS FOR ADVICE ON HOW TO SOLVE THIS ISSUE!

Importing the numpy C-extensions failed. This error can happen for
many reasons, often due to issues with your setup or how NumPy was
installed.

We have compiled some common reasons and troubleshooting tips at:

    https://numpy.org/devdocs/user/troubleshooting-importerror.html

Please note and check the following:

  * The Python version is: Python3.13 from "/home/user/projects/rix_uv/.venv/bin/python3"
  * The NumPy version is: "2.2.6"

and make sure that they are the versions you expect. Please carefully study the
documentation linked above for further help.

Original error was: libstdc++.so.6: cannot open shared object file: No such file or directory
```

That is an issue when using *wheels* (wheels are binaries of Python packages
that get installed by default using `uv`). These wheels expect certain libraries to be 
in certain places. One way to solve this is to add the following to your shell hook:

```r
shellHook = ''
   # Export LD_LIBRARY is required for python packages that dynamically load libraries, such as numpy 
   export LD_LIBRARY_PATH="${pkgs.lib.makeLibraryPath (with pkgs; [ zlib gcc.cc glibc stdenv.cc.cc ])}":LD_LIBRARY_PATH;
   ...
   '';
```

Your environment should now work.

If this seems complicated: yes, and that is actually exactly the type of
problems that Nix aims to solve. However, there are just too many Python
packages to automate their inclusion into nixpkgs like how it’s done for R. If
you can, prefer using the Python packages included in nixpkgs.


## Configuring your IDE

### Pre-requisites

We now need to configure an IDE to use both our Nix shells as development
environments, and GitHub Copilot. You are free to use whatever IDE you want but
the instructions below are going to focus on Positron, which is a fork of VS
Code geared towards data science. It works well with both Python and R and makes
it quite easy to choose the right R or Python interpreter (which you'll have to
do to make sure you're using the one provided by Nix, [see
here](https://positron.posit.co/managing-interpreters.html)).

If you want to use VS Code proper, you can follow all the instructions here, but
you need to install the
[REditorSupport](https://marketplace.visualstudio.com/items?itemName=REditorSupport.r)
and the
[Python](https://marketplace.visualstudio.com/items?itemName=ms-python.python)
extension. You will also need to add the `{languageserver}` R package to the
shell:

```r
rix(
  date = "2025-08-04",
  r_pkgs = c("dplyr", "ggplot2", "languageserver"),
  py_conf = list(
    py_version = "3.13",
    py_pkgs = c("polars", "great-tables")
  ),
  ide = "none",
  project_path = ".",
  overwrite = TRUE
)
```

and re-create the `default.nix` file.

You'll need to carefully select the Python interpereter provided by
Nix, and not the other environments that you might already have on your system.
Also, we recommend you uninstall R if it's installed system-wide and also remove
your local library of packages and instead only use dedicated Nix shells to
manage your projects. While we made our possible for Nix shells to not interfere
with a system-installed R, we recommend users go into the habit of taking some
minutes at the start of a project to properly set up their development
environment.

On Windows, you need to install Positron on Windows, not inside WSL. Then,
install the [Open Remote
extension](https://open-vsx.org/extension/kv9898/open-remote-wsl) right from
Positron itself.

### direnv

Once Positron is installed, you need to install a piece of software called
`direnv`: `direnv` will automatically load Nix shells when you open a project
that contains a `default.nix` file in an editor. It works on any operating
system and many editors support it, including Positron. If you're using Windows,
install `direnv` in WSL (even though you’ve just installed Positron for
Windows). To install `direnv` run this command:

```bash
nix-env -f '<nixpkgs>' -iA direnv
```

This will install `direnv` and make it available even outside of Nix shells!

Then, we highly recommend to install the `nix-direnv` extension:

```bash
nix-env -f '<nixpkgs>' -iA nix-direnv
```

It is not mandatory to use `nix-direnv` if you already have `direnv`, but it'll
make loading environments much faster and seamless.

Finally, if you haven't used `direnv` before, don't forget [this last
step](https://direnv.net/docs/hook.html) to make your terminal detected and load
`direnv` automatically.

Then, in Positron, install the [direnv](https://github.com/direnv/direnv-vscode)
extension. Finally, add a file called `.envrc` and simply write the following
two lines in it (this `.envrc` file should be in the same folder as your
project's `default.nix`):

```bash
use nix
mkdir $TMP
```

in it. On Windows, *remotely connect to WSL* first, but on other operating
systems, simply open the project's folder using `File > Open Folder...` and you
will see a pop-up stating `direnv: /PATH/TO/PROJECT/.envrc is blocked` and a
button to allow it. Click `Allow` and then open an R script. You might get
another pop-up asking you to restart the extension, so click `Restart`. Be aware
that at this point, `direnv` will run `nix-shell` and so will start building the
environment. If that particular environment hasn't been built and cached yet, it
might take some time before Code will be able to interact with it. You might get
yet another popup, this time from the R Code extension complaining that R can't
be found. In this case, simply restart Code and open the project folder again:
now it should work every time.

Sometimes, dependending on platform and installed packages, Positron might not
be able to correctly load a Nix-managed Python interpreter. This happens when
it tries to load its own version of `ipykernal`. To make sure this doesn’t cause
issues, add these lines to the shell’s definition in `default.nix`:

```r
shellHook = ''
   # Export LD_LIBRARY is required for python packages that dynamically load libraries, such as numpy 
   export LD_LIBRARY_PATH="${pkgs.lib.makeLibraryPath (with pkgs; [ zlib gcc.cc glibc stdenv.cc.cc ])}":LD_LIBRARY_PATH;
   ...
   '';
```

### In summary and next steps

For a new project, simply repeat this process:

- Generate the project's `default.nix` file;
- Build it using `nix-build`;
- Create an `.envrc` and write the two lines from above in it;
- Open the project's folder in Code and click allow when prompted;
- Restart the extension and Code if necessary.

Another option is to create the `.envrc` file and write `use nix` in it, then
open a terminal, navigate to the project's folder, and run `direnv allow`. Doing
this before opening Positron should not prompt you anymore.

If you're on Windows, using Positron like this is particularly interesting, because
it allows you to install Positron on Windows as usual, and then you can configure
it to interact with a Nix shell, even if it's running from WSL. This is a very
seamless experience.

Now configure Positron to use GitHub Copilot:
[click here](https://positron.posit.co/assistant.html).

You can enable LLM tab-completion if you want. I’m not a fan of this, I prefer
simply using the interface and using LLMs as an advanced rubber duck:
[https://github.com/copilot/](https://github.com/copilot/).

## Starting a new project:

To start a new project, create a new directory, and `cd` into it. 
Then, in that folder, create a new script called `gen-env.R` and add
the following:

```r
library(rix)

rix(
  date = "2025-09-22",
  r_pkgs = c(
    "languageserver", # if you want to use VS Code
    "tidyverse" # or whatever packages
  ),
  py_conf = list(
    py_version = "3.13",
    py_pkgs = c("polars", "great-tables")
  ),
  ide = "none",
  project_path = ".",
  overwrite = TRUE,
  print = TRUE
)
```

Then call:

```r
nix-shell -I nixpkgs=https://github.com/rstats-on-nix/nixpkgs/archive/refs/heads/2025-09-22.tar.gz -p R rPackages.rix
```

providing a url to my fork of `nixpkgs` makes sure that you get the latest `rix` version (change the date in the url 
to a more recent one if needed). Start R by typing `R` in the shell, and then `source("gen-env.R")`. That will create
a `default.nix` which you can then drop into using `nix-shell`. Then create an `.envrc` and add the lines from before,
and you’re done! 

Note: if you want to use `uv` instead of Nix to manage the Python packages, follow the instructions above.

## Hands-On Exercises

1. Start a temporary shell with R and `{rix}` again using
  `nix-shell -p R rPackages.rix`. Start an R session (by typing `R`)
  and then load the `{rix}` package (using `library(rix)`).
  Run the `available_dates()` function: using the latest available date,
  generate a new `default.nix`.
2. Inside of an activated shell, type `which R` and `echo $PATH`. Explore what
  is being added to your environment. What is the significance of paths like
  `/nix/store/...`?
3. Break it on purpose: generate a new environment with a wrong R package name,
  for example `dplyrnaught`. Try to build the environment. What happens?
4. Go to [https://search.nixos.org/packages](https://search.nixos.org/packages)
  and look for packages that you usually use for your projects to see if they
  are available.
