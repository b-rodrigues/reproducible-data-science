{"title":"Project start","markdown":{"headingText":"Project start","containsRefs":false,"markdown":"\nIn this chapter, we are going to work together on a very simple project. This\nproject will stay with us until the end of the book. As we will go deeper into\nthe book together, you will rewrite that project by implementing the techniques\nI will teach you. By the end of the book you will have built a reproducible\nanalytical pipeline. To get things going, we are going to keep it simple; our\ngoal here is to get an analysis done, that's it. We won't focus on\nreproducibility (well, not beyond what was done in the previous chapter to set\nup our development environment). We are going to download some data, and analyse\nit, that's it.\n\n## Housing in Luxembourg\n\nWe are going to download data about house prices in Luxembourg. Luxembourg is a\nlittle Western European country the author hails from that looks like a shoe and\nis about the size of .98 Rhode Islands. Did you know that Luxembourg is a\nconstitutional monarchy, and not a kingdom like Belgium, but a Grand-Duchy, and\nactually the last Grand-Duchy in the World? Also, what you should know to\nunderstand what we will be doing is that the country of Luxembourg is divided\ninto Cantons, and each Cantons into Communes. If Luxembourg was the USA, Cantons\nwould be States and Communes would be Counties (or Parishes or Boroughs). What’s\nconfusing is that “Luxembourg” is also the name of a Canton, and of a Commune,\nwhich also has the status of a city and is the capital of the country. So\nLuxembourg the country, is divided into Cantons, one of which is called\nLuxembourg as well, cantons are divided into communes, and inside the canton of\nLuxembourg, there's the commune of Luxembourg which is also the city of\nLuxembourg, sometimes called Luxembourg City, which is the capital of the\ncountry.\n\n::: {.content-hidden when-format=\"pdf\"}\n<figure>\n    <img src=\"images/lux_rhode_island.png\"\n         alt=\"Luxembourg is about as big as the US State of Rhode Island.\"></img>\n    <figcaption>Luxembourg is about as big as the US State of Rhode Island.</figcaption>\n</figure>\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n```{r, echo = F, out.width=\"300px\"}\n#| fig-cap: \"Luxembourg is about as big as the US State of Rhode Island.\"\nknitr::include_graphics(\"images/lux_rhode_island.png\")\n```\n:::\n\nWhat you should also know is that the population is about 672'050 people as of\nwriting (July 2024), half of which are foreigners. Around 400'000 persons work\nin Luxembourg, of which half do not live in Luxembourg; so every morning from\nMonday to Friday, 200'000 people enter the country to work and then leave in the\nevening to go back to either Belgium, France or Germany, the neighbouring\ncountries. As you can imagine, this puts enormous pressure on the transportation\nsystem and on the roads, but also on the housing market; everyone wants to live\nin Luxembourg to avoid the horrible daily commute, and everyone wants to live\neither in the capital city, or in the second largest urban area in the south, in\na city called Esch-sur-Alzette.\n\nThe plot below shows the value of the House Price Index (HPI) over time for\nLuxembourg and the European Union:\n\n```{r, echo = F}\n#https://ec.europa.eu/eurostat/databrowser/bookmark/21530d9a-c423-4ab7-998a-7170326136cd?lang=en\nhousing_lu_eu <- read.csv(\"datasets/prc_hpi_a__custom_4705395_page_linear.csv.gz\")\n\nwithr::with_package(\"ggplot2\",\n  {\n    ggplot(data = housing_lu_eu) +\n      geom_line(aes(y = OBS_VALUE, x = TIME_PERIOD, group = geo, colour = geo),\n                linewidth = 1.5) +\n      labs(title = \"House price and sales index (2010 = 100)\",\n           caption = \"Source: Eurostat\") +\n      theme_minimal() +\n      theme(legend.position = \"bottom\")\n  }\n  )\n\n```\n\nIf you want to download the data and follow along, click\n[here](https://github.com/b-rodrigues/rap4all/raw/master/datasets/prc_hpi_a__custom_4705395_page_linear.csv.gz)^[https://is.gd/AET0ir].\n\nLet us take a look at the definition of the HPI (taken from the HPI's\n[metadata](https://archive.is/OrQwA)^[https://archive.is/OrQwA, archived link\nfor posterity.] page):\n\n*The House Price Index (HPI) measures inflation in the residential property\nmarket. The HPI captures price changes of all types of dwellings purchased by\nhouseholds (flats, detached houses, terraced houses, etc.). Only transacted\ndwellings are considered, self-build dwellings are excluded. The land component\nof the dwelling is included.*\n\nSo from the plot, we can see that the price of dwellings more than doubled\nbetween 2010 and 2021; the value of the index is 214.81 in 2021 for Luxembourg,\nand 138.92 for the European Union as a whole.\n\nThere is a lot of heterogeneity though; the capital and the communes right next\nto the capital are much more expensive than communes from the less densely\npopulated north, for example. The south of the country is also more expensive\nthan the north, but not as much as the capital and surrounding communes. Not\nonly is price driven by demand, but also by scarcity; in 2021, 0.5% of residents\nowned 50% of the buildable land for housing purposes (Source: *Observatoire de\nl'Habitat, Note 29*, [archived download\nlink](https://archive.org/download/note-29/note-29.pdf)^[https://archive.org/download/note-29/note-29.pdf]).\n\nOur project will be quite simple; we are going to download some data, supplied\nas an Excel file, compiled by the Housing Observatory (*Observatoire de\nl'Habitat*, a service from the Ministry of Housing, which monitors the evolution\nof prices in the housing market, among other useful services like the\nidentification of vacant lots). The advantage of their data when compared to\nEurostat's data is that the data is disaggregated by commune. The disadvantage\nis that they only supply nominal prices, and no index (and the data is trapped\ninside Excel and not ready for analysis with Python). Nominal prices are the\nprices that you read on price tags in shops. The problem with nominal prices is\nthat it is difficult to compare them through time. Ask yourself the following\nquestion: would you prefer to have had 500€ (or USDs) in 2003 or in 2023? You\nprobably would have preferred them in 2003, as you could purchase a lot more\nwith $500 then than now. In fact, according to a random inflation calculator I\ngoogled, to match the purchasing power of $500 in 2003, you'd need to have $793\nin 2023 (and I'd say that we find very similar values for €). But it doesn't\nreally matter if that calculation is 100% correct: what matters is that the\nvalue of money changes, and comparisons through time are difficult, hence why an\nindex is quite useful. So we are going to convert these nominal prices to real\nprices. Real prices take inflation into account and so allow us to compare\nprices through time.\n\nSo to summarise; our goal is to:\n\n- Get data trapped inside an Excel file into a neat data frame;\n- Convert nominal to real prices using a simple method;\n- Make some tables and plots and call it a day (for now).\n\nWe are going to start in the most basic way possible; we are simply going to\nwrite a script and deal with each step separately.\n\n::: {.content-visible when-format=\"pdf\"}\n\\newpage\n:::\n\n## Saving trapped data from Excel\n\nGetting data from Excel into a tidy data frame can be very tricky. This is\nbecause very often, Excel is used as some kind of dashboard or presentation\ntool. So data is made human-readable, in contrast to machine-readable. Let us\nquickly discuss this topic as it is essential to grasp the difference between\nthe two (and in my experience, a lot of collective pain inflicted to\nstatisticians and researchers could have been avoided if this concept was more\nwell-known). The picture below shows an Excel file made for human consumption:\n\n::: {.content-hidden when-format=\"pdf\"}\n<figure>\n    <img src=\"images/obs_hab_xlsx_overview.png\"\n         alt=\"An Excel file meant for human eyes.\"></img>\n    <figcaption>An Excel file meant for human eyes.</figcaption>\n</figure>\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n```{r, echo = F}\n#| fig-cap: \"An Excel file meant for human eyes.\"\nknitr::include_graphics(\"images/obs_hab_xlsx_overview.png\")\n```\n:::\n\nSo why is this file not machine-readable? Here are some issues:\n\n- The table does not start in the top-left corner of the spreadsheet, which is\n  where most importing tools expect it to be;\n- The spreadsheet starts with a header that contains an image and some text;\n- Numbers are actually text and use \",\" as the thousands separator;\n- You don't see it in the screenshot, but each year is in a separate sheet.\n\nThat being said, this Excel file is still very tame, and going from this Excel\nto a tidy data frame will not be too difficult. In fact, we suspect that whoever\nmade this Excel file is well aware of the contradicting requirements of human\nand machine-readable formatting of data, and strove to find a compromise.\nBecause more often than not, getting human-readable data into a machine-readable\nformat is a nightmare. We could call data like this *machine-friendly* data.\n\nIf you want to follow along, you can download the Excel file\n[here](https://github.com/b-rodrigues/rap4all/raw/master/datasets/vente-maison-2010-2021.xlsx)^[https://is.gd/1vvBAc]\n(downloaded on January 2023 from the [luxembourguish open data\nportal](https://data.public.lu/en/datasets/prix-annonces-des-logements-par-commune/)^[https://data.public.lu/en/datasets/prix-annonces-des-logements-par-commune/]).\nBut you don’t need to follow along with code, because I will link the completed\nscripts for you to download later.\n\nEach sheet contains a dataset with the following columns:\n\n- *Commune*: the commune (the smallest administrative division of territory);\n- *Nombre d'offres*: the total number of selling offers;\n- *Prix moyen annoncé en Euros courants*: Average selling price in nominal Euros;\n- *Prix moyen annoncé au m2 en Euros courants*: Average selling price in square meters in nominal Euros.\n\nFor ease of presentation, I'm going to show you each step of the analysis here\nseparately, but I'll be putting everything together in a single script once\nI'm done explaining each step. So first, let's import the main packages I'll\nbe using for the analysis (I'll need to import some others as I go):\n\n```{python}\nimport polars as pl\nimport polars.selectors as cs\nimport re\n```\n\nI will be using the `polars` package to manipulate data and `polars.selectors`\ncontains handy functions to refer to columns while `re` is for regular\nexpressions which I will need below.\n\nNext, the code below downloads the data, and puts it in a data frame:\n\n```{python}\n# The url below points to an Excel file\n# hosted on the book's github repository\nurl = \"https://is.gd/1vvBAc\"\n\n# Let's first download the file into a temporary file and then\n# return its path\nfrom tempfile import NamedTemporaryFile\nfrom requests import get\n\nresponse = get(url)\n\nwith NamedTemporaryFile(delete = False, suffix = '.xlsx') as temp_file:\n    temp_file.write(response.content)\n    temp_file_path = temp_file.name\n```\n\nThe code above downloads the Excel file, saves it in a temporary folder and\nreturns the path to the file. We can now use `temp_file_path` to read the data\nusing `pl.read_excel()`.\n\nNext, I will write a function to read all the sheets of the Excel workbook.\nIdeally, this wouldn't be needed, because `polars` can read all the sheets of an\nExcel workbook in one go and return a list of sheets, but I want to add a column\nwith the year. So I write this function that reads one sheet and adds the year\ncolumn, and then I map this function over a list of sheet names:\n\n```{python}\ndef read_excel(excel_file, sheet):\n    out = pl.read_excel(\n            engine = 'xlsx2csv',\n            source = excel_file,\n            sheet_name = sheet,\n            schema_overrides = {\"Nombre d'offres\": pl.String},\n            read_options = {\n            \"skip_rows\": 6,\n            \"has_header\": True\n            }\n          ).with_columns(pl.lit(sheet).alias(\"year\"))\n    return out\n```\n\nI set some options in the `pl.read_excel()` function to correctly read the file.\nI'll let you play around with these options to see what happens if you don't set\nthem.\n\nI now need a little helper function that I will use to map over the sheet names.\nThis function sets the `excel_file` argument of the previously defined\n`read_excel()` function we wrote to `temp_file_path` which points to the Excel\nfile. I will then map over its `sheet` argument.\n\n```{python}\ndef wrap_read_excel(sheet):\n    out = read_excel(excel_file = temp_file_path,\n                          sheet = sheet)\n    return out\n```\n\nLet's now create the list of sheet names:\n\n```{python}\nsheets = list(map(str, range(2010, 2022)))\n```\n\nI can now map the function over the list of sheets and concatenate them into a\nsingle polars data frame using `pl.concat()`:\n\n```{python}\nraw_data = pl.concat(list(map(wrap_read_excel, sheets)))\n```\n\nIn the preface, I mentioned that the Python code in this book would have a very\ndistinct R-like accent. Mapping over a list instead of writing a for-loop is an\nexample of this. Feel free to use a for-loop if you're more comfortable with\nthem!\n\nThe next function will be used below to clean the column names. For example, a\ncolumn called something like `\"House prices in €\"` would get changed to\n`\"house_prices_in_\"`, removing the `\"€\"` sign, replacing spaces with `\"_\"`\nsetting the string to lower case. If I was using `pandas`, I could have used\n`clean_columns()` from the `skimpy` package, but unfortunately this function\ndoesn't work with `polars` data frames. So I wrote this little function to clean\nthe column names instead, partly inspired by the `clean_names()` function from\nthe `{janitor}` R package.\n\n```{python}\ndef clean_names(string):\n    # inspired by https://nadeauinnovations.com/post/2020/11/python-tricks-replace-all-non-alphanumeric-characters-in-a-string/\n    clean_string = [s for s in string if s.isalnum() or s.isspace()]\n    out = \"\".join(clean_string).lower()\n    out = re.sub(r\"\\s+\", \"_\", out)\n    out = out.encode(\"ascii\", \"ignore\").decode(\"utf-8\")\n    return out\n```\n\nWe need to map `clean_names()` to each column. We can select all the columns\nusing `pl.all()` and map the function to the column’s `name` attribute.\n\n```{python}\nraw_data = raw_data.select(pl.all().name.map(clean_names))\n```\n\nFinally, let's rename some columns and do some more cleaning:\n  - converting column types\n  - ensuring consistent names for the communes (for example, sometimes the\n    commune of Luxembourg is spelled \"Luxembourg\", sometimes \"Luxembourg-Ville\"\n  - converting columns to their right types (but not the `n_offers` column\n    yet...)\n\nThis is all done in the snippet below:\n\n```{python}\nraw_data = (\n    raw_data\n    .rename(\n      {\n        \"commune\": \"locality\",\n        \"nombre_doffres\": \"n_offers\",\n        \"prix_moyen_annonc_en_courant\": \"average_price_nominal_euros\",\n        \"prix_moyen_annonc_au_m_en_courant\": \"average_price_m2_nominal_euros\"\n      }\n    )\n    .with_columns(\n      cs.all().str.strip_chars()\n    )\n    .with_columns(\n      cs.contains(\"average\").cast(pl.Float64, strict = False)\n    )\n    .with_columns(\n      # In some sheets it's \"Luxembourg\", in others it's \"Luxembourg-Ville\"\n      pl.col(\"locality\").str.replace_all(\"Luxembourg.*\", \"Luxembourg\")\n    )\n    .with_columns(\n      # In some sheets it's \"Pétange\", in others it's \"Petange\"\n      pl.col(\"locality\").str.replace_all(\"P.*tange\", \"Pétange\")\n    )\n)\n```\n\nIn practice, it is unlikely that you would have written the above code in one\ngo. Instead you would have checked the data, done something on it, then checked\nit again, etc. But as I mentioned this is not a book about learning how to clean\ndata, so let's just take this code as-is.\n\nIf you are familiar with the `{tidyverse}` [@wickham2019b] family of packages\nfrom the R programming language, the above code should be quite relatively easy\nto follow. If you are more familiar with `pandas`, I believe that reading the\ncode above should still be easy as well. What might be more difficult if you\nwere brought up on Python exclusively is mapping functions to elements of lists\ninstead of using for-loops. Don't worry about it too much, and use for-loops if\nyou wish. Just remember that this book is not about Python per se, but about\nbuilding reproducible pipelines. The focus will be on other things.\n\nRunning this code results in a tidy data set:\n\n```{python}\nraw_data\n```\n\nBut as you can see at the bottom, we still have some stuff that doesn't belong\nin the `locality` column. Let's also check for missing values in the\n`\"average_price_nominal_euros\"` column:\n\n```{python}\n(\nraw_data\n  .filter(pl.col(\"average_price_nominal_euros\").is_null())\n)\n\n```\n\nIt turns out that there are no prices for certain communes, but that we also\nhave some rows with garbage in there. Let's go back to the raw data to see what\nthis is about:\n\n::: {.content-hidden when-format=\"pdf\"}\n<figure>\n    <img src=\"images/obs_hab_xlsx_missing.png\"\n         alt=\"Always look at your data.\"></img>\n    <figcaption>Always look at your data.</figcaption>\n</figure>\n:::\n\n::: {.content-visible when-format=\"pdf\"}\n```{r, echo = F}\n#| fig-cap: \"Always look at your data.\"\nknitr::include_graphics(\"images/obs_hab_xlsx_missing.png\")\n```\n:::\n\nSo it turns out that there are some rows that we need to remove. We can start by\nremoving rows where `locality` is missing. Then we have a row where `locality`\nis equal to \"Total d'offres\". This is simply the total of every offer from every\ncommune. We could keep that in a separate data frame, or even remove it. The\nvery last row states the source of the data and we can also remove it. Finally,\nin the screenshot above, we see another row that we don't see in our filtered\ndata frame: one where `n_offers` would be missing. This row gives the national\naverage for columns `average_prince_nominal_euros` and\n`average_price_m2_nominal_euros`. What we are going to do is create two\ndatasets: one with data on communes, and the other on national prices. Let's\nfirst remove the rows stating the sources:\n\n```{python}\nraw_data = (\n    raw_data\n    .filter(~pl.col(\"locality\").str.contains(\"Source\"))\n)\n```\n\nLet's now only keep the communes in our data:\n\n```{python}\ncommune_level_data = (\n    raw_data\n    .filter(~pl.col(\"locality\").str.contains(\"nationale|offres\"))\n    .filter(pl.col(\"locality\").is_not_null())\n    # This is needed on Windows...\n    .with_columns(\n        pl.col(\"locality\").str.replace_all(\"\\351\", \"é\")\n    )\n    .with_columns(\n        pl.col(\"locality\").str.replace_all(\"\\373\", \"û\")\n    )\n    .with_columns(\n        pl.col(\"locality\").str.replace_all(\"\\344\", \"ä\")\n    )\n)\n```\n\nAnd let's create a dataset with the national data as well:\n\n```{python}\ncountry_level = (\n    raw_data\n    .filter(pl.col(\"locality\").str.contains(\"nationale\"))\n    .select(cs.exclude(\"n_offers\"))\n)\n\noffers_country = (\n    raw_data\n    .filter(pl.col(\"locality\").str.contains(\"Total d.offres\"))\n    .select([\"year\", \"n_offers\"])\n)\n\ncountry_level_data = (\n    country_level.join(offers_country, on = \"year\")\n    .with_columns(pl.lit(\"Grand-Duchy of Luxembourg\").alias(\"locality\"))\n)\n\n```\n\nLet's take a look at it:\n\n```{python}\ncountry_level_data\n```\n\nNow the data looks clean, and we can start the actual analysis... or can we?\nBefore proceeding, it would be nice to make sure that we got every commune in\nthere. For this, we need a list of communes from Luxembourg. [Thankfully,\nWikipedia has such a\nlist](https://en.wikipedia.org/wiki/List_of_communes_of_Luxembourg)^[https://w.wiki/6nPu].\n\nAn issue with scraping tables off the web is that they might change in the\nfuture. It is therefore a good idea to save the page by right clicking on it and\nthen selecting save as, and then re-hosting it. I use Github pages to re-host\nthe Wikipedia page above\n[here](https://b-rodrigues.github.io/list_communes/)^[https://is.gd/lux_communes].\nI now have full control of this page, and won't get any bad surprises if someone\ndecides to eventually update it. Instead of re-hosting it, you could simply save\nit as any other file of your project.\n\nSo let's scrape and save this list. Let's first load the required packages:\n\n```{python}\n#| label: Scraping communes\n\nfrom urllib.request import urlopen\nfrom bs4 import BeautifulSoup\nfrom pandas import read_html\nfrom io import StringIO\n```\n\nand let's get the raw data:\n\n```{python}\nurl = 'https://b-rodrigues.github.io/list_communes/'\n\nhtml = urlopen(url)\n\ntables = (\n    BeautifulSoup(html, 'html.parser')\n    .find_all(\"table\")\n)\n\ncurrent_communes_raw = read_html(StringIO(str(tables[1])))[0]\n```\n\nI won't go into much details, but the using `Beautifoulsoup()` it is possible to\nparse the `html` from the web page and get the tables out using the\n`.find_all()` method. The first table from that list is the one we're interested\nin, and using the `read_html()` function from the `pandas` package we can get\nthat table into a data frame (turns out we can't completely avoid using\n`pandas`!).\n\nWe can now use `polars` to clean the table:\n\n```{python}\n#| label: Cleaning communes\n\n# current_communes has a MultiIndex, so drop it\ncurrent_communes_raw.columns = current_communes_raw.columns.droplevel()\n\ncurrent_communes_pl = (\n    pl.DataFrame(current_communes_raw)\n    .select(pl.col(\"Name.1\").alias(\"commune\"))\n    .with_columns(\n        pl.col(\"commune\").str.replace_all(\"\\351\", \"é\")\n    )\n    .with_columns(\n        pl.col(\"commune\").str.replace_all(\"\\373\", \"û\")\n    )\n    .with_columns(\n        pl.col(\"commune\").str.replace_all(\"\\344\", \"ä\")\n    )\n    .with_columns(\n    # This removes the dagger symbol next to certain communes names\n    # in other words it turns \"Commune †\" into \"Commune\".\n        pl.col(\"commune\").str.replace_all(\" .$\", \"\")\n    )\n)\n```\n\nFinally, we can save the communes into a simple list:\n\n```{python}\ncurrent_communes = list(current_communes_pl[\"commune\"])\n```\n\nLet's see if we have all the communes in our data, if the \ncode below results in an empty list, then we're good:\n\n```{python}\n(\ncommune_level_data\n .filter(~pl.col(\"locality\").is_in(current_communes))\n .get_column(\"locality\")\n .unique()\n .sort()\n .to_list()\n)\n```\n\nWe see many communes that are in our `commune_level_data`, but not in\n`current_communes`. There’s one obvious reason: differences in spelling, for\nexample, \"Kaerjeng\" in our data, but \"Käerjeng\" in the table from Wikipedia. But\nthere’s also a less obvious reason; since 2010, several communes have merged\ninto new ones. So there are communes that are in our data in 2010 and 2011, but\ndisappear from 2012 onwards. So we need to do several things: first, get a list\nof all existing communes from 2010 onwards, and then, harmonise spelling. Here\nagain, we can use a list from Wikipedia, and here again, I decide to re-host it\non Github pages to avoid problems in the future:\n\n```{python}\n#| label: Scraping former communes\n\n# Need to also check former communes\nurl = 'https://b-rodrigues.github.io/former_communes/#Former_communes/'\n\nhtml = urlopen(url)\n\ntables = (\n    BeautifulSoup(html, 'html.parser')\n    .find_all(\"table\")\n)\n\n# The third table (...hence the '2' in tables[2]...) is the one we need\nformer_communes_raw = read_html(StringIO(str(tables[2])))[0]\n\nformer_communes_pl = (\n    pl.DataFrame(former_communes_raw)\n    .with_columns(\n        pl.col(\"Name\").str.replace_all(\"\\351\", \"é\")\n    )\n    .with_columns(\n        pl.col(\"Name\").str.replace_all(\"\\373\", \"û\")\n    )\n    .with_columns(\n        pl.col(\"Name\").str.replace_all(\"\\344\", \"ä\")\n    )\n    .select(pl.col(\"Name\").alias(\"commune\"))\n)\n\nformer_communes_pl\n```\n\nAs you can see, since 2010 many communes have merged to form new ones. We can\nnow combine the list of current and former communes:\n\n```{python}\n#| label: Combining communes\n\n# Combine former and current communes\n\ncommunes = (\n    pl.concat([former_communes_pl, current_communes_pl])\n    .get_column(\"commune\")\n    .unique()\n    .sort()\n    .to_list()\n)\n\n\n(\ncommune_level_data\n    .filter(~pl.col(\"locality\").is_in(communes))\n    .get_column(\"locality\")\n    .unique()\n    .sort()\n    .to_list()\n)\n```\n\nAnd now we can harmonize the spelling:\n\n```{python}\n#| label: Harmonising spelling\n\n# There's certain communes with different spelling between\n# wikipedia and our data, so let's correct the spelling\n# on the wikipedia ones\n# ['Clémency', 'Erpeldange', 'Kaerjeng', 'Luxembourg', 'Pétange']\n\ncommunes_clean = (\n    pl.concat([former_communes_pl, current_communes_pl])\n    .with_columns(\n        pl.when(pl.col(\"commune\").str.contains(\"Cl.mency\"))\n          .then(pl.lit(\"Clémency\"))\n          .otherwise(pl.col(\"commune\")).alias(\"commune\")\n    )\n    .with_columns(\n        pl.when(pl.col(\"commune\").str.contains(\"Erpeldange\"))\n          .then(pl.lit(\"Erpeldange\"))\n          .otherwise(pl.col(\"commune\")).alias(\"commune\")\n    )\n    .with_columns(\n        pl.when(pl.col(\"commune\").str.contains(\"City\"))\n          .then(pl.lit(\"Luxembourg\"))\n          .otherwise(pl.col(\"commune\")).alias(\"commune\")\n    )\n    .with_columns(\n        pl.when(pl.col(\"commune\").str.contains(\"K.*jeng\"))\n          .then(pl.lit(\"Kaerjeng\"))\n          .otherwise(pl.col(\"commune\")).alias(\"commune\")\n    )\n    .with_columns(\n        pl.when(pl.col(\"commune\").str.contains(\"P.*tange\"))\n          .then(pl.lit(\"Pétange\"))\n          .otherwise(pl.col(\"commune\")).alias(\"commune\")\n    )\n    .get_column(\"commune\")\n    .unique()\n    .sort()\n    .to_list()\n)\n```\n\nLet’s run our test again:\n\n```{python}\n(\ncommune_level_data\n    .filter(~pl.col(\"locality\").is_in(communes_clean))\n    .get_column(\"locality\")\n    .unique()\n    .sort()\n    .to_list()\n)\n```\n\nGreat! When we compare the communes that are in our data with every commune that\nhas existed since 2010, we don't have any commune that is unaccounted for. So\nare we done with cleaning the data? Yes, we can now start with analysing the\ndata. Take a look\n[here](https://raw.githubusercontent.com/b-rodrigues/raps_with_py/master/scripts/save_data.py)^[https://is.gd/bGvNKG]\nto see the finalised script. Also read some of the comments that I’ve added.\nThis is a typical Python script, and at first glance, one might wonder what is\nwrong with it. Actually, not much, but the problem if you leave this script as\nit is, is that it is very likely that we will have problems rerunning it in the\nfuture. As it turns out, this script is not reproducible. But we will discuss\nthis in much more detail later on. For now, let’s analyse our cleaned data.\n\n## Analysing the data\n\nWe are now going to analyse the data. The first thing we are going to do is\ncompute a Laspeyeres price index. This price index allows us to make comparisons\nthrough time; for example, the index at year 2012 measures how much more\nexpensive (or cheaper) housing became relative to the base year (2010). However,\nsince we only have one 'good' (housing), this index becomes quite simple to\ncompute: it is nothing but the prices at year *t* divided by the prices in 2010\n(if we had a basket of goods, we would need to use the Laspeyeres index formula\nto compute the index at all periods).\n\nFor this section, I will perform a rather simple analysis. I will immediately\nshow you the script: take a look at it\n[here](https://raw.githubusercontent.com/b-rodrigues/raps_with_py/master/scripts/analysis.py)^[https://is.gd/7MqLjX].\nFor the analysis I selected 5 communes and plotted the evolution of prices\ncompared to the national average.\n\nThis analysis might seem trivially simple, but it contains all the needed\ningredients to illustrate everything else that I’m going to teach you in this\nbook.\n\nMost analyses would stop here: after all, we have what we need; our goal was to\nget the plots for the 5 communes of Luxembourg, Esch-sur-Alzette, Mamer,\nSchengen (which gave its name to the [Schengen\nArea](https://en.wikipedia.org/wiki/Schengen_Area)^[https://en.wikipedia.org/wiki/Schengen_Area])\nand Wincrange. However, let’s ask ourselves the following important questions:\n\n- How easy would it be for someone else to rerun the analysis?\n- How easy would it be to update the analysis once new data gets published?\n- How easy would it be to reuse this code for other projects?\n- What guarantee do we have that if the scripts get run in 5 years, with the same input data, we get the same output?\n\nLet’s answer these questions one by one.\n\n## Your project is not done\n\n### How easy would it be for someone else to rerun the analysis?\n\nThe analysis is composed of two Python scripts, one to prepare the data, and\nanother to actually run the analysis proper. Performing the analysis might seem\nquite easy, because each script contains comments as to what is going on, and\nthe code is not that complicated. However, we are missing any project-level\ndocumentation that would provide clear instructions as to how to run the\nanalysis. This might seem simple for us who wrote these scripts, but we are\nfamiliar with Python, and this is still fresh in our brains. Should someone less\nfamiliar with Python have to run the script, there is no clue for them as to how\nthey should do it. And of course, should the analysis be more complex (suppose\nit’s composed of dozens of scripts), this gets even worse. It might not even be\neasy for you to remember how to run this in 5 months!\n\nAnd what about the required dependencies? Many packages were used in the analysis. How should these get installed? Ideally, the same versions of the packages you used and the same version of Python should get used by that person to rerun the analysis. Thankfully, you can share the `Pipfile` and the `Pipfile.lock` files from the previous chapters to make it easier for them, so by setting up our development environment, we also made it easier for future you or replicators to install the required dependencies!\n\n### How easy would it be to update the project?\n\nIf new data gets published, all the points discussed previously are still valid,\nplus you need to make sure that the updated data is still close enough to the\nprevious data such that it can pass through the data cleaning steps you wrote.\nYou should also make sure that the update did not introduce a mistake in past\ndata, or at least alert you if that is the case. Sometimes, when new years get\nadded, data for previous years also get corrected, so it would be nice to make\nsure that you know this. Also, in the specific case of our data, communes might\nget fused into a new one, or maybe even divided into smaller communes (even\nthough this has not happened in a long time, it is not entirely out of the\nquestion).\n\nIn summary, what is missing from the current project are enough tests to make\nsure that an update to the data can happen smoothly.\n\n### How easy would it be to reuse this code for another project?\n\nSaid plainly, not very easy. With code in this state you have no choice but to\ncopy and paste it into a new script and change it adequately. For re-usability,\nnothing beats structuring your code into functions and ideally you would even\npackage them. We are going to learn just that in future chapters of this book.\n\nBut sometimes you might not be interested in reusing code for another project:\nhowever, even if that’s the case, structuring your code into functions and\npackaging them makes it easy to reuse code even inside the same project. Look at\nthe last part of the `analysis.py` script: we copied and pasted the same code 5\ntimes and only slightly changed it. We are going to learn how not to repeat\nourselves by using functions and you will immediately see the benefits of\nwriting functions, even when simply reusing them inside the same project.\n\n### What guarantee do we have that the output is stable through time?\n\nNow this might seem weird: after all, if we start from the same dataset, does it\nmatter *when* we run the scripts? We should be getting the same result if we\nbuild the project today, in 5 months or in 5 years. Well, not necessarily.\nProgramming languages such as Python evolve quickly, and packages even more so.\nThere is no guarantee that the authors of the packages will not change the\npackage’s functions to work differently, or take arguments in a different order,\nor even that the packages will all be available at all in 5 years. And even if\nthe packages are still available and function the same, bugs in the packages\nmight get corrected which could alter the result. This might seem like a\nnon-problem; after all, if bugs get corrected, shouldn’t you be happy to update\nyour results as well? But this depends on what it is we’re talking about.\nSometimes it is necessary to reproduce results exactly as they were, even if\nthey were wrong, for example in the context of an audit.\n\nSo we also need a way to somehow snapshot and freeze the computational\nenvironment that was used to create the project originally.\n\n## Conclusion\n\nWe now have a basic analysis that has all we need to get started. In the coming\nchapters, we are going to learn about topics that will make it easy to write\ncode that is more robust, better documented and tested, and most importantly\neasy to rerun (and thus to reproduce the results). The first step will actually\nnot involve having to start rewriting our scripts though; next, we are going to\nlearn about Git, a tool that will make our life easier by versioning our code.\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","include-in-header":{"file":"header.html"},"css":["epub.css"],"output-file":"project_start.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.33","bibliography":["references.bib"],"theme":{"light":"flatly","dark":"solar"}},"extensions":{"book":{"multiFile":true}}},"epub":{"identifier":{"display-name":"ePub","target-format":"epub","base-format":"epub"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"epub","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":false,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"default-image-extension":"png","html-math-method":"mathml","to":"epub","toc":true,"css":["epub.css"],"output-file":"project_start.epub"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"bibliography":["references.bib"],"lang":"en-GB","date":"2025-12-31"},"extensions":{"book":{"selfContainedOutput":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":true,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":"H","fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","include-in-header":{"text":"\\usepackage{fvextra}\n\\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines,commandchars=\\\\\\{\\}}\n\\areaset[0.50in]{4.5in}{8in}\n"},"include-before-body":{"text":"\\RecustomVerbatimEnvironment{verbatim}{Verbatim}{\n   showspaces = false,\n   showtabs = false,\n   breaksymbolleft={},\n   breaklines\n   % Note: setting commandchars=\\\\\\{\\} here will cause an error\n}\n"},"output-file":"project_start.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"documentclass":"scrbook","classoption":["paper=6in:9in","pagesize=pdftex","headinclude=on","footinclude=on","12pt"]},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","epub","pdf"]}