{
  "hash": "88f12665dc49d8c73f6b50faa74e22e8",
  "result": {
    "engine": "jupyter",
    "markdown": "# Setting up a development environment\n\nI have to start with one of the hardest chapters of the book, which is how to\nset up a development environment for Python.\n\nIf you are already using Python, you are likely already familiar with setting up\nper-project development environments using tools like `pyenv`. I would still\nsuggest you read this chapter and see if you agree with how I approach this\nissue. You may want to adapt your current workflow to it, or keep on doing what\nyou’ve been doing up until now, it is up to. If you're completely new to Python,\nthen you definitely need to read this chapter, but also, I need to remind you\nthat this is not a book about Python per se. So I won't be teaching you any\nPython (I wouldn't really be competent to do so either) and you might want to\ncomplement reading this book with another that focuses on actually teaching you\nPython. Remember, this book is about building reproducible analytical pipelines!\n\n## Why is installing Python such a hard problem?\n\nIf you google \"how to install Python\" you will find a surprising amount of\narticles explaining how to do it. I say \"surprising amount\" because one might\nexpect to install Python like any other piece of software. If you’re already\nfamiliar with R, you could think that installing Python would be done the same\nway: download the installer for your operating system, and then install it. And,\nactually, you can do just that for Python as well. So why are there 100s of\narticles online explaining how to install Python, and why aren't all of these\narticles simply telling you to download the installer to install Python? Why did\nI write this chapter on installing Python?\n\nWell, there are several thing that we need to deal with if we want to install\nand use Python the \"right way\". First of all, Python is pre-installed on Linux\ndistributions and older versions of macOS. So if you're using one of these\noperating systems, you could use the built-in Python interpreter, but this is\nnot recommended. The reason being that these bundled versions are generally\nolder, and that you don't control their upgrade process, as these get updated\nalongside the operating system. On Windows and newer versions of macOS, Python\nis, as far as I know, never bundled, so you'd need to install it anyways.\n\nAnother reason why you should install a Python version and manage it yourself,\nis that newer Python versions can introduce breaking changes, making code\nwritten for an earlier version of Python not run on a newer version of Python.\nThis is not a Python-specific issue: it happens with any programming language.\nSo this means that ideally you would want to bundle a Python version with your\nproject's code.\n\nThe same holds true for individual packages: newer versions of packages might\nnot even work with older releases of Python, so to avoid any issues, an analysis\nwould get bundled with a Python release and Python packages. This bundle is what\nI call a development environment, and in order to build such development\nenvironments, specific tools have to be used. And there's a lot of these tools\nin the Python ecosystem... so much so that when you're first starting, you might\nget lost. So here are the two tools that I use for this, and that I think work\nquite well together: `micromamba` and `pipenv`.\n\nThe workflow is as follows:\n\n- Install `micromamba`, a lightweight package manager.\n- Using `micromamba`, create an environment that contains a Python interpreter and the `pipenv` package.\n- Using this environment, install the required packages using `pipenv`.\n- `pipenv` will automatically generate two very useful files, `Pipfile` and `Pipfile.lock`.\n\nIn the following sections I detail this process.\n\n## Creating a project-specific development environment\n\nWhat we want is to have project-specific development environments that should\ninclude a specific Python version, specific versions of Python packages and all\nthe code to actually run the project. If you do this, you have already achieved\na great deal to make your analysis reproducible. Some would even argue that it\nis enough!\n\nI'm going to assume that you don't have any Python version available on your\ncomputer and need to get one. Let’s suppose that Python version 3.12.1 is the\nlatest released version, and let’s also suppose that you would like to use that\nversion to start working on a project. To first get the right Python interpreter\nready, you should install `micromamba`. Please refer to the `micromamba`\ndocumentation\n[here](https://mamba.readthedocs.io/en/latest/installation/micromamba-installation.html#automatic-install)^[https://mamba.readthedocs.io/en/latest/installation/micromamba-installation.html#automatic-install]\nbut on Linux, macOS and Git Bash on Windows (there’s also instructions for\nPowershell, if you don’t have Git Bash installed on Windows), it should be as\neasy as running this in your terminal:\n\n```bash\n\"${SHELL}\" <(curl -L micro.mamba.pm/install.sh)\n```\n\nfor Poweshell use instead `Invoke-Expression ((Invoke-WebRequest -Uri https://micro.mamba.pm/install.ps1).Content)`\ninstead.\n\nWe can now use `micromamba` to create an environment that will contain a Python\ninterpreter for our project and `pipenv`. Type the following command to create\nthis environment:\n\n```bash\nmicromamba create -n housing python=3.12.1 pipenv\n```\n\nThis will create an environment named \"pipenv_env\" that includes `pipenv` and\nthe version 3.12.1 of Python. If you're just starting a project, you can safely\nchoose the very latest released version (check the releases pages on Python's\nwebsite).\n\nWe can now use `pipenv` to install the packages for our project. But why don’t\nwe just use the more common `pip` instead of `pipenv`, or even `micromamba`\nwhich can also install any other Python package that we require for our\nprojects? Why introduce yet another tool? In my opinion, `pipenv` has one\nabsolutely crucial feature for reproducibility: `pipenv` enables deterministic\nbuilds, which means that when using `pipenv`, we will *always* get exactly the\nsame packages installed.\n\n\"But isn’t that exctaly what using `requirements.txt` file does?\" you wonder.\nYou are not entirely wrong. After all, if you make the effort to specify the\npackages you need, and their versions, wouldn't running `pip install -r\nrequirements.txt` also install exactly the same packages? (If you don't know\nwhat a `requirements.txt` file is, you can think of it as a simple text file\nthat lists the required packages and their versions for an analysis).\n\nWell, not quite. Imagine for example that you need a package called `hello`\nand you put it into your `requirements.txt` like so:\n\n```bash\nhello==1.0.1\n```\n\nSuppose that `hello` depends on another package called `ciao`. If you run `pip\ninstall -r requirements.txt` today, you’ll get `hello` at version `1.0.1` and\n`ciao`, say, at version `0.3.2`. But if you run `pip install -r\nrequirements.txt` in 6 months, you would still get `hello` at version `1.0.1`\nbut you might get a newer version of `ciao`. This is because `ciao` itself is\nnot specified in the `requirements.txt`, unless you made sure to add it (and\nthen also add its dependencies, and their dependencies...). This mismatch in the\nversions of `ciao` can cause issues. `pipenv` takes care of this for you by\ngenerating a so-called *lock* file automatically, and adds further security\nchecks by comparing sha256 hashes from the lock file to the ones from the\ndownloaded packages, making sure that you are actually installing what you\nbelieve you are.\n\nWhat about using `micromamba`? `micromamba` could indeed be used to install the\nproject’s dependencies, but would require another tool called `conda-lock` to\ngenerate lock files, and in my experience, using `conda-lock` doesn't always\nwork. I have had 0 issues with `pipenv` on the other hand.\n\nIn any case, the point is that you should use a tool that specifies dependencies\nvery strictly and precisely. Use whatever you're comfortable with if you already\nare familiar with one such tool. If not, and you want to follow along, use\n`pipenv` but take some time to check out other options. I personally use Nix,\nwhich is not specific to Python, but I decided not to discuss Nix in this book,\nbecause to properly discuss it, it would require a book on its own.\n\nNow that `pipenv` is installed, let's start using it to install the packages we\nneed for our project. Because the Python interpreter was installed using\n`micromamba`, we either need to activate the environment to get access to it, or\nwe should use `micromamba run` to run the Python intpreter from this\nenvironment. First, create a folder called `housing`, which will contain our\nanalysis scripts. Then, from that folder, run the following command:\n\n```bash\nmicromamba run -n housing pipenv install polars==1.1.0 plotnine beautifulsoup4 pandas plotnine lxml pyarrow requests xlsx2csv\n```\n\nAs you can see, I chose to install specific versions of `polars`. This is\nbecause I want you to follow along with the same versions as in the book. You\ncould remove the `==x.y.z` string from the command above to install the latest\nversions of `polars` available if you prefer, but then there would be no\nguarantee that you would find the same results as I do in the remainder of the\nbook. You could also specify versions for the other packages if you wish.\nA little sidnote: some of these packages we are not really going to be using,\nbut they're needed either as dependencies for `polars` or because we need\none single function from them. The packages in question are \n`pandas`, `lxml` and `pyarrow`.\n\nYou should now see two new files in the `housing` folder, `Pipfile` and\n`Pipfile.lock`. Start by opening `Pipfile`, it should look like this:\n\n```\n[[source]]\nurl = \"https://pypi.org/simple\"\nverify_ssl = true\nname = \"pypi\"\n\n[packages]\npolars = \"==1.1.0\"\nplotnine = \"*\"\nbeautifulsoup4 = \"*\"\npandas = \"*\"\nskimpy = \"*\"\n\n[dev-packages]\n\n[requires]\npython_version = \"3.12\"\n```\n\nI think that this file is pretty self-evident: the packages being used for this\nproject are listed alongside their versions. The Python version is also listed.\nSometimes, depending on how you set up the project, it could happen that the\nPython version listed is not the one you want for your project. In this case, I\nhighly recommend you change the version to the right one. Also, you'll notice\nthat here the Python version is \"3.12\", but we specified version \"3.12.1\" with\n`micromamba` when we created the environment. I would recommend that you add the\nmissing \".1\" for maximum reproducibility. If you edited the `Pipfile` then you\nneed to run `pipenv lock` to regenerate the `Pipfile.lock` file as well:\n\n```bash\nmicromamba run -n housing pipenv lock\n```\n\nthis will make sure to also set the required/correct Python version in there.\n\nIf you open the `Pipfile.lock` in a text editor, you will see that it is a json\nfile and that also lists the dependecies of your project, but also the\ndependencies' dependencies. You will also notice several fields called `hashes`.\nThese are there for security reasons: whenever someone, (or you in the future)\nwill regenerate this environment, the packages will get downloaded and their\nhashes will get compared to the ones listed in the `Pipfile.lock`. If they don’t\nmatch, then something very wrong is happening and packages won’t get installed.\nThese two files are very important, because they will make sure that it will be\npossible to regenerate the same environment on another machine.\n\nTo check whether everything installed correctly, drop into the development shell using:\n\n```bash\nmicromamba run -r housing pipenv shell\n```\n\nand check that the right version of Python is being used:\n\n```bash\npython --version\n```\n\nThis should print `Python 3.12.1` in the terminal. Start the Python interpreter\nand let's check `polars`'s version:\n\n```bash\npython\n```\n\nThen check that the correct versions of the packages were installed:\n\n::: {#97e554a1 .cell execution_count=1}\n``` {.python .cell-code}\nimport polars as pl\npl.__version__\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'1.31.0'\n```\n:::\n:::\n\n\nYou should see `1.1.0` as the listed version. Quit the shell, and then\nquit the environment with `exit`.\n\n## One last thing\n\nBefore continuing, it would be nice if we would automatically drop into the\nenvironment each time we are in the right folder; so for example, each time we\nnavigate to the `housing` folder for our project on housing, the `housing`\nenvironment starts. We can achieve this by using a tool called `direnv`.\n\nI won't go into details to install `direnv`, simply consult the\n[documentation](https://direnv.net/docs/installation.html).\n\nThe next step is to start a shell in your environment by running `micromamba run\n-n housing pipenv shell`. This will start a shell inside the `housing`\nenvironment by executing `pipenv shell`. Take note of the command that appears,\nin my case it's this: \n`. /home/b-rodrigues/.local/share/virtualenvs/py_housing-MvX0wC5I/bin/activate`\n(pay attention to the `.` character at the very beginning of this command!).\n\nIn the root folder of the `housing` project, create an empty text file and name\nit `.envrc`. Inside of that file, paste the line from before into the empty\n`.envrc` file. Finally, run `direnv allow` in a terminal in that folder, and\neach time you will navigate to this folder using a terminal, that development\nenvironment will be used. Many development interfaces can work together with\n`direnv`, refer to their documentation to learn how to configure your IDE to\nmake use of `direnv`.\n\n## A high-level description of how to set up a project\n\nOk, so to summarise, we installed `micromamba` which will make it easy to\ninstall any version of Python that we require, and we also installed `pipenv`,\nwhich we use to install packages. The advantage of using `pipenv` is that we get\ndeterministic builds, and `pipenv` works well with `micromamba` to build\nproject-specific environments.\n\nThe way I would suggest you use these tools now, is that for each project, you\ninstall the latest available version of Python and then install packages by\nspecyifing their versions, like so:\n\n```bash\nmicromamba create -n project_name python=X.YY.Z pipenv\n```\n\nthen, use this environment in a fresh folder to install the packages you need, for\ninstance:\n\n```\nmicromamba run -n housing pipenv install beautifulsoup4==4.12.2 polars==1.1.0 plotnine==0.12.4\n```\n\n(Replace the versions of Python and packages by the latest, or those you need.)\n\nThis will ensure that your project uses the correct software stack, and that\ncollaborators or future you will be able to regenerate this environment by\ncalling `pipenv sync`. This is also the command that we will use later, in the\nchapter on CI/CD.\n\nIf you need to add packages to an environment, run:\n`micromamba run -n housing pipenv install great_tables`\n(or simply if `pipenv install great_tables` if you're already in the activated\n`housing` environment).\n\n",
    "supporting": [
      "setting_up_files"
    ],
    "filters": [],
    "includes": {}
  }
}